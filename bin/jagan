#!/usr/bin/env ruby -Ku

require 'optparse'
require 'bundler/setup'
require 'eventmachine'
require 'logger'

# Alias write to << so that Rack::CommonLogger can write to log
class ::Logger
  alias_method :write, :<<
end

options = {
  api_host: '0.0.0.0', api_port: '4567', websocket_host: '0.0.0.0',
  websocket_port: '8080', debug: false, redis_address: 'redis://0.0.0.0:6379/0', 
  log_level: ::Logger::WARN, log_file: $stdout, audit_log_file: $stdout, api_log_file: $stdout,
  statistics: false, mongo:false, mongo_host: 'localhost', mongo_port: '27017', mongo_db: 'jagan'
  }

opts_app_id = nil
opts_app_key = nil
opts_secret = nil 

OptionParser.new do |opts|
  opts.on '-h', '--help', 'Display this screen' do
    exit
  end

  opts.on '-i', '--app_id APP_ID', "Pusher application id" do |k|
    opts_app_id = k
  end

  opts.on '-k', '--app_key APP_KEY', "Pusher application key" do |k|
    opts_app_key = k
  end

  opts.on '-s', '--secret SECRET', "Pusher application secret" do |k|
    opts_secret = k
  end

  opts.on '-r', '--redis_address URL', "Address to bind to (Default: redis://127.0.0.1:6379/0)" do |h|
    options[:redis_address] = h
  end

  opts.on '--redis_write_address URL', "Address to bind to for writes and publishes" do |h|
    options[:redis_write_address] = h
  end

  opts.on '-a', '--api_host HOST', "API service address (Default: 0.0.0.0:4567)" do |p|
    options[:api_host], options[:api_port] = p.split(':')
  end

  opts.on '-w', '--websocket_host HOST', "WebSocket service address (Default: 0.0.0.0:8080)" do |p|
    options[:websocket_host], options[:websocket_port] = p.split(':')
  end

  opts.on '-l', '--log-level LEVEL', "Log level (Default: warn)" do |p|
    levels =  {
      fatal: ::Logger::FATAL,
      error: ::Logger::ERROR,
      warn: ::Logger::WARN,
      info: ::Logger::INFO,
      debug: ::Logger::DEBUG
    }
    param_level = levels[p.to_sym]
    raise RuntimeError.new "Log level unknown. Accepted values are: " + levels.keys.join(', ') if param_level.nil?
    options[:log_level] = param_level
  end

  opts.on '--log-file FILE', "Log file" do |p|
    tmpfile = File.new(p, "a")
    tmpfile.sync = true
    options[:log_file] = tmpfile
  end

  opts.on '--audit-log-file FILE', "Audit log file" do |p|
    tmpfile = File.new(p, "a")
    tmpfile.sync = true
    options[:audit_log_file] = tmpfile
  end

  opts.on '--api-log-file FILE', "API log file" do |p|
    tmpfile = File.new(p, "a")
    tmpfile.sync = true
    options[:api_log_file] = tmpfile
  end

  opts.on '--api-log-file FILE', "API log file" do |p|
    tmpfile = File.new(p, "a")
    tmpfile.sync = true
    options[:api_log_file] = tmpfile
  end

  opts.on '--id IDENTIFIER', 'Unique identified' do |p|
    options[:jagan_id] = p
  end

  opts.on '--statistics on/off', 'Statistics flag' do |p|
    values =  {
      on: true,
      off: false
    }
    param_statistics = values[p.to_sym]
    raise RuntimeError.new "Statistics flag unknown. Accepted values are: " + values.keys.join(', ') if param_statistics.nil?
    options[:statistics] = param_statistics
    if param_statistics 
      # Statistics needs the cluster to know which jagan is master
      options[:cluster] = true
      # Statistics needs mongodb
      options[:mongo] = true
    end
  end

  opts.on '--admin-http-user USER', 'HTTP user for statistics and REST API calls' do |p|
    options[:admin_http_user] = p
  end

  opts.on '--admin-http-password PASSWORD', 'HTTP password for statistics and REST API calls' do |p|
    options[:admin_http_password] = p
  end

  opts.on '--mongo on/off', 'Use mongodb' do |p|
    values =  {
      on: true,
      off: false
    }
    param_mongo = values[p.to_sym]
    raise RuntimeError.new "Mongo flag unknown. Accepted values are: " + values.keys.join(', ') if param_mongo.nil?
    options[:mongo] = param_mongo
  end

  opts.on '--mongo-host HOST', 'Mongodb host' do |p|
    options[:mongo_host] = p
  end

  opts.on '--mongo-port PORT', 'Mongodb port' do |p|
    options[:mongo_port] = Integer(p)
  end

  opts.on '--mongo-db DB', 'Mongodb database' do |p|
    options[:mongo_db] = p
  end

  opts.on "-v", "--[no-]verbose", "Run verbosely" do |v|
    options[:debug] = v
  end
end.parse!

# Checks
if (not options[:statistics].nil?) && options[:jagan_id].nil?
  # Statistics needs the cluster so they need a jagan_id
  raise RuntimeError.new "Statistics need the --jagan-id parameter."
end

# Set up configuration
File.tap do |f|
  require f.expand_path(f.join(f.dirname(__FILE__),'..', 'lib', 'jagan', 'config.rb'))
end
Jagan::Config.load options

EM.run do
  File.tap { |f| require f.expand_path(f.join(f.dirname(__FILE__),'..', 'jagan.rb')) }
  Jagan::Cluster
  Jagan::Statistics
  Jagan::Applications
  # Are all application parameters missing ?
  if [opts_app_id, opts_app_key, opts_secret].any?{|item| not item.nil?}
    # No, some were given, verify that all are present
    %w<app_id app_key secret>.each do |parameter|
      raise RuntimeError.new "--#{parameter} STRING is a required argument. Use your Pusher #{parameter}." unless eval "opts_" + parameter
    end
    # All parameters are present, add the application
    Jagan::Applications.add(opts_app_id, opts_app_key, opts_secret)
  end
  Jagan::Service.run

  puts "      d88b  .d8b.   d888b   .d8b.  d8b   db   "
  puts "      `8P' d8' `8b 88' Y8b d8' `8b 888o  88   "
  puts "       88  88ooo88 88      88ooo88 88V8o 88   "
  puts "       88  88~~~88 88  ooo 88~~~88 88 V8o88   "
  puts "   db. 88  88   88 88. ~8~ 88   88 88  V888   "
  puts "   Y8888P  YP   YP  Y888P  YP   YP VP   V8P   "
  puts "\n" * 2

  puts "Jagan API server listening on port #{options[:api_port]}"
  puts "Jagan WebSocket server listening on port #{options[:websocket_port]}"
end
